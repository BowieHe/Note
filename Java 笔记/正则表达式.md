正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

因为`\` 在java中是转义字符，因此在java中用`\\s`表示`\s`

### 元字符介绍

-   **"^"** ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。 
- **"$"** ：$会匹配行或字符串的结尾

比如`^This is Java$`，会匹配This开头，Java结尾的字符

-  **"\b"** :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中"This is Regex"匹配单独的单词 "is" 正则就要写成 "\bis\b"  
            \b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界 

-  **"\d"**: 匹配数字，
            例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123  正则:^0\d\d\d-\d\d\d\d\d\d\d$ 这里只是为了介绍"\d"字符，实际上有更好的写法在下面

- **"\w"**：匹配字母，数字，下划线.

  ​         例如我要匹配"a2345BCD__TTz" 正则："\w+"  这里的"+"字符为一个量词指重复的次数，稍后会详细介绍。 

- **"\s"**：匹配空格 

  　　  例如字符 "a b c" 正则："\w\s\w\s\w"  一个字符后跟一个空格，如有字符间有多个空格直接把"\s" 写成 "\s+" 让空格重复

-  **"."**：匹配除了换行符以外的任何字符
  　　  这个算是"\w"的加强版了"\w"不能匹配 空格 如果把字符串加上空格用"\w"就受限了，看下用 "."是如何匹配字符"a23 4 5 B C D__TTz"  正则：".+"

-  **"[abc]"**: 字符组  匹配包含括号内元素的字符 

  ​    这个比较简单了只匹配括号内存在的字符，还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了，

### 几种反义

反义写法将原来的小写改写成大写，意思与原来的相反

-  **"\W**  匹配任意不是字母，数字，下划线 的字符
-  **"\S"**  匹配任意不是空白符的字符
- **"\D"** 匹配任意非数字的字符
-   **"\B"** 匹配不是单词开头或结束的位置
-  "[^abc\] " 匹配除了abc以外的任意字符

### 量词

- 贪婪，如"*"字符。
  贪婪字符会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果失败则退一个字符，然后再次尝试回退的过程叫回朔。每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。贪婪对资源的消耗是最大的

- 懒惰，比如"?"
  懒惰量词使用另一种方式匹配，他从目标的起始位置开始尝试匹配，每次检查一个字符，并找到要匹配的内容，如此循环直到字符结尾处

- 占有。比如"+"
  占有量词会覆盖整个目标字符串，然后尝试寻找匹配内容，但是只尝试一次，不会回朔。

- **"\*"(贪婪)**  重复零次或更多

  　　　  例如"aaaaaaaa" 匹配字符串中所有的a  正则： "a*"  会出到所有的字符"a"

- **"+"(懒惰)**  重复一次或更多次

  　　   例如"aaaaaaaa" 匹配字符串中所有的a  正则： "a+"  会取到字符中所有的a字符，  "a+"与"a*"不同在于"+"至少是一次而"*" 可以是0次，

  　　   稍后会与"?"字符结合来体现这种区别

- **"?"(占有)**  重复零次或一次

  　　   例如"aaaaaaaa" 匹配字符串中的a 正则 ： "a?" 只会匹配一次，也就是结果只是单个字符a

- **"{n}"** 重复n次

  　　   例如从"aaaaaaaa" 匹配字符串的a 并重复3次 正则：  "a{3}"  结果就是取到3个a字符  "aaa";

- **"{n,m}"** 重复n到m次

  　　   例如正则 "a{3,4}" 将a重复匹配3次或者4次 所以供匹配的字符可以是三个"aaa"也可以是四个"aaaa" 正则都可以匹配到

- **"{n,}"** 重复n次或更多次

   　   与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则"a{3,}" a至少要重复3次

量词了解之后，之前的匹配电话号码的正则可以`^0\d\d\d-\d\d\d\d\d\d\d$`改成`^0\d{2,3}-\d{7}`

### 懒惰限定符

- **"\*?"**  重复任意次，但尽可能少重复 

  　　   如 "acbacb"  正则  "a.*?b" 只会取到第一个"acb" 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而"acbacb"最少字符的结果就是"acb" 

- **"+?"** 重复1次或更多次，但尽可能少重复

  　　  与上面一样，只是至少要重复1次

- **"??"** 重复0次或1次，但尽可能少重复

  　　   如 "aaacb" 正则 "a.??b" 只会取到最后的三个字符"acb"

- **"{n,m}?"** 重复n到m次，但尽可能少重复

  ​     如 "aaaaaaaa"  正则 "a{0,m}" 因为最少是0次所以取到结果为空

- **"{n,}?"**   重复n次以上，但尽可能少重复

  ​     如 "aaaaaaa"  正则 "a{1,}" 最少是1次所以取到结果为 "a"

# 捕获分组

捕获分组，其实就是一个括号内的内容 如 "(\d)\d" 而"(\d)" 这就是一个捕获分组，可以对捕获分组进行 后向引用 (如果后而有相同的内容则可以直接引用前面定义的捕获组，以简化表达式) 如(\d)\d\1 这里的"\1"就是对"(\d)"的后向引用

如  "zery zery" 正则 \b(\w+)\b\s\1\b 所以这里的"\1"所捕获到的字符也是 与(\w+)一样的"zery"，为了让组名更有意义，组名是可以自定义名字的

"\b(?<name>\w+)\b\s\k<name>\b" 用"?<name>"就可以自定义组名了而要后向引用组时要记得写成 "\k<name>";自定义组名后,捕获组中匹配到的值就会保存在定义的组名里

**捕获分组的常用方法**

- **"(exp)"**   匹配exp,并捕获文本到自动命名的组里
- **"(?exp)"**  匹配exp,并捕获文本到名称为name的组里
- **"(?:exp)"** 匹配exp,不捕获匹配的文本，也不给此分组分配组号

下面是零宽断言

- **"(?=exp)"** 匹配exp前面的位置

  　　如 "How are you doing" 正则"(?<txt>.+(?=ing))" 这里取ing前所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为"How are you do";

- **"(?<=exp)"** 匹配exp后面的位置

  　　如 "How are you doing" 正则"(?<txt>(?<=How).+)" 这里取"How"之后所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为" are you doing";

- **"(?!exp)"** 匹配后面跟的不是exp的位置

  　　如 "123abc" 正则 "\d{3}(?!\d)"匹配3位数字后非数字的结果

- **"(?<!exp)"** 匹配前面不是exp的位置

  　　如 "abc123 " 正则 "(?<![0-9])123" 匹配"123"前面是非数字的结果也可写成"(?!<\d)123"

